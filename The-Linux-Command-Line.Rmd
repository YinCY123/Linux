---
title: "The Linux Command Line"
author: "yincy"
date: "8/26/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Navigation
1. `pwd`: print name of current working directory.  
2. `cd`: change directory.  
    - `cd`: change the working directory to your home directory.  
    - `cd -`: changes the working directory to the previous working directory.  
    - `cd ~user_name`: change the working directory to the home directory of `user_name`.  
3. `ls`: list directory contents.  
4. `.`: refers to the working directory.  
5. `..`: refers to the working directory's parent directory.  


**Absolute and relative pathnames**  
An absolute pathanme begins with the root directory and follows the tree branch by branch until the path to the desired directory or file is completed.  

A relative pathname starts from the working directory to the destination.  


# Exploring the system
1. `file`: determine file type.  
2. `less`: view file contents.  
    - `ls ~ /usr`
    - `ls -l`
    

**Options and arguments**  
```
command -options arguments
```

# Manipulating Files and Directories
1. `cp`: copy files and directories  
    - `cp item1 item2`: copy single file or directory 'item1' to file or directory 'item2'  
    - `cp item ... directory`: copy multiple items into a directory  
    - `cp file1 file2`: copy file1 to file2, if file2 exists, it is overwritten with the contents of file1. If file2 does not exist, it is created.  
    - `cp -i file1 file2`: same as above, except that if file2 exists, the user is prompted before it is overwritten.  
    - `cp file1 file22 dir1`: copy file1 and file2 into directory dir1. dir1 must already exist.  
    - `cp dir1/* dir2`: Using a wildcard, all the files in dir1 are copied into dir2, dir2 must already exist.  
    - `cp -r file1 file2`: copy the contents of directory dir1 to directory dir2. If directory dir2 does not exist, it is created and, after the copy, will contain the same contents as directory dir1.  

2. `mv`: move/rename files and directories  
    - `mv item1 item2`: move or rename file or directory item1 to item2.  
    - `mv item ... directory`: move one or more items from one directory to another.  
3. `mkdir`: create directories  
4. `rm`: remove files and directories  
5. `ln`: create hard and symbolic links   
    - `ln file link`: create a hard link
    - `ln -s item link`: create a symbolic link, where 'item' is either a file or a directory.  



**Hard and Symbolic Links**  
- Hard links are the original Unix way of creating links, compared to symbolic links, which are more modern. By default, every file has a single hard link that gives the file its name. When we create a hard link, we create an additional directory entry for a file.  
- A hard link cannot reference a file outside its own file system. This means a link cannot reference a file that is not on the same disk partition as the link itself.  
- A hard link may not reference a directory.  
- A hard link is indistinguishable from the file itself. When a hard link is deleted, the link is removed but the contents of the file itself continue to exist until all links to the file are deleted.  
- Symbolic links are created to overcome the limitations of hard links. Symbolic links work by creating a special type of file that contains a text pointer to the referenced file or directory. In this regard, they operate in much the same way as a Windows shortcut though of course, they predate the Windows feature by many years.  
- When you delete a symbolic link, only the link is deleted, not the file itself. If the file is deleted before the symbolic link, the link will continue to exist, but will point to nothing.  
- Symbolic links were created to overcome the two disadvantages of hard links, hard links cannot span physical devices and hard links cannot reference directories, only files.  
- Symbolic links are a special type of file that contains a text pointer to the target file or directory.  
- When we create a symbolic link, we are creating a text description of where the target file is relative to the symbolic link.  


**Wildcards**  

|**Wildcard**|**Meaning**|
|--|--|
|`*`|matches any characters|
|`?`|matches any single character|
|`[characters]`|matches any character that is a member of the set characters|
|`[!characters]`|matches an character that is not a member of the set|
|`[[:class:]]`|matches any character that is a member of the specified class|


----


**Commonly Used Character Classes**   

|**Character Class**|**Meaning**| 
|--|--|
|`[:alnum:]`|matches any alphanumeric character|
|`[:alpha:]`|matches any alphabetic character|
|`[:digit:]`|matches any numeral|
|`[:lower:]`|matches any lowercase letter|
|`[:upper:]`|matches any uppercase letter|

Wildcards can be used with any command that accepts filenames as arguments.  


# Working with Commands
1. `type`: indicate how a command name is interpreted.  
2. `which`: display which executable program will be executed, the location of the program.  
    - `which` only works for executable programs, not builtins nor aliases that are substitutes for actual executable programs.  
3. `help`: get help for shell builtins.  
4. `man`: display a command's manual page.  
5. `apropos`: display a list of appropriate commands.  
6. `info`: display a command's info entry.  
7. `whatis`: display a very brief description of command.  
8. `alias`: create an alias for a command.  


**What exactly are commands?**  
- **An executable program** like all those files we saw in `/usr/bin`. Within this category, programs can be compiled binaries such as programs writtern in C and C++, or programs can be written in scripting languages such as shell, perl, python, ruby, etc.  

- **A command built into the shell itself**. bash supports a number of commands internally called shell builtins. The `cd` command, for exmaple, is a shell builtin.  

- **A shell function**. These are miniature shell scripts introduced into the environment.  

- **An alias**. Commands that we can define ourselves, built from other commands.  


**Getting A command's documentation**  
- `help`: get help for shell builtins.  
- `--help`: display usage information for executable programs.  
- `man`: display executable program's manual page.  
    - `man section_number command`: man 8 cp  
- `apropos`: display appropriate commands  
    - search the list of man pages for possible matches based on a search term.  
- `whatis`: display a very brief description of a command.  
- `info`: display a program's info entry.  
    - The info program reads info files, which are tree structured into individuals nodes, each containing a single topic. Info files contain hyperlinks that can be move you from one node to node.  

- `alias`: create command from commands
    - `alias new_command='string'`  
    - `alias foo='cd /usr; ls -lh; cd -'`  
    - to remove an alias using `unalias`  
    - to see all the alias defined in the environment, use the `alias` command without arguments.  


> it is possible to put more than one command on a line by separating each command with a semicolon character.  

```
cd /usr; ls -lh; cd -
```


**man page organization**  

|**Section**|**Contents**|
|:--|:--|
|`1`|User commands|
|`2`|Programming interfaces kernel system calls|
|`3`|Programming interfaces to the C library|
|`4`|Special files such as device nodes and drivers|
|`5`|File formats and conventions|
|`6`|Games and amusements such as screen savers|
|`7`|Miscellanous|
|`8`|System administration commands|



# redirection  
- `cat`: display file content or concatenate files.  
    - `cat *.tiff > merge.tiff`.  
- `sort`: sort lines of text.  
- `uniq`: report or omit repeated lines.  
- `grep`: print lines matching a pattern, when `grep` encounters a 'pattern' in the file, it prints out the lines containing it.  
    - `grep pattern [file...]`  

- `wc`: print newlines, word and byte counts for each file.  
- `head`: Output the first part of a file.    
- `tail`: Output the last part of a file.  
- `tee`: read from standard input and write to standard output and files. Allowing the data to continue down the pipeline.   
- `|`: piplines  
- `>`: redirection standard output.  
- `>>`: redirection standard output with append.  
- `2&>`: redirection standard error.  



Redirecting standard output and standard error to one file.  
The direction of standard error must always occur after redirecting standard output or it doesn't work.  
```
ls -l /bin/usr > ls-output.txt 2>&1

ls -l /bin/usr &> ls-output.txt

ls -l /bin/usr &>> ls-output.txt
```

disposing of unwanted output
```
ls -l /bin/usr 2> /dev/null
```

redirecting standard output and standard error to one file
```
ls -l /bin/usr/ > ls-output 2>&1

ls -l /bin/usr &> ls-output                                                                                              ,                                                                    
```

The redirection of standard error must always occur after redirecting standard output or it doesn't work.


**file description**  

>>standard input: 0  
>>standard output: 1  
>>standard error: 2  


**Pipelines**  
```
command1 | command2

ls -lh /usr/bin | less
```

**The difference between > and |**  
The direction operator connects a command with a file while the pipeline operator connects the ouput of one command with the input of a second command.  
```{bash}
ls -lh /usr/bin | head
```


# Seeing the world as the shell sees it 
1. echo 


## expansion  
### pathname expansion  
```{bash}
ls -dl /home/yincy/D*
```


### tilde expansion  
```{bash}
echo ~
echo ~yincy
```

### arithmetic expansion use the form: $((expression))  
```{bash}
echo $((2 + 2))
echo $(($((5**2)) * 3))
echo $(((5**2) * 3))

echo five divided by two equals $((5/2))
echo with $((5%2)) left over
```
arithmetic expansion only supports integers, but can perform a number of different operations.  

**supported arithmetic Operations**  
|:--|:--|
|`+`| addition|
|`-`| subtraction|
|`*`| Multiplication|
|`/`| division (the results are integers).|
|`%`| modulo, which simply means 'remainder'.|
|`**`| exponentiation|



### brace expansion  
```{bash}
echo fornt-{A,B,C}-back
echo number_{1..5}
echo {01..15}
echo {001..15}
echo {z..a}
echo {Z..A}
echo a{A{1,2},B{3,4}}b
```


### parameter expansion  
```{bash}
echo $USER
```


### command substitution
Command substitution allows us to use the output of a command as an expansion.  
```{bash}
echo $(ls -l)
ls -lh $(which cp)

file $(ls -d /usr/bin/* | grep zip)

# there is an alternative syntax for command substitution
ls -lh `which cp`
```

### quoting  
- Double quotes: if you place text inside double quotes, all the special characters used by the shell lose their special meaning and are treated as ordinary characters. The exceptions are "$", "\", and "`". This means that word-splitting, pathname expansion, tilde expansion, and brace expansion are suppressed, but parameter expansion, arithmetic expansion, and command substitutions are still carried out.  

- Single quotes: suppress all expansions.  


```{bash}
# double quote suppress some character, single quotes suppress all
> `two words.txt`

ls -l two words.txt
ls -l "two words.txt"

```

- `\`: escaping characters  


# Advanced Keyboard Tricks
1. `clear`: clear the screen  
2. `history`: display the contents of the history list  


## history  
1. `clear`: clear the screen  
2. `history`  
3. `!!`: re-execute the previous command  
4. `!77`: re-execute the history command 77  
5. `!string`: repeat last history list item starting with string.  
6. `!?string`: repeat last history list item containing string.  
7. `Ctrl-r`: search history incrementally, press again to find the next matched command.  
8. `Ctrl-j`: copy the line from the searched history to the current command line.  
9. `Ctrl-c`: or `Ctrl-g` quit the history search.  


# permissions  
1. `id`: display user identity.  
2. `umask`: set the default file permissions when it is created.  
3. `su`: run a shell as another user.  
4. `sudo`: execute a command as another user.  
5. `chown`: change a file's owner.  
    - `chown [owner][:[group]] file`.  
6. `chgrp`: change group ownership. (much work can be done by chown)  
7. `chmod`: change file mode. only the file's owner or the superuser can change the mode of a file or directory.  
8. `adduser`( recommanded)  
9. `useradd`  
10. `groupadd`  


**File Types**  
|**Attribute**|**File Type**|
|:--|:--|
|`-`| A regular file|
|`d`| A directory|
|`l`| A symbolic link. Notice that with symbolic links, the remaining file attributes are always 'rwxrwxrwx' and are dummy values. The real file attributes are those of the file the symbolic link points to.|
|`c`| A character special file. This file type refers to a device that handles data as a stream of bytes, such as a terminal or modem.|
|`b`| A block special file. This file type refers to a device that handles data in blocks, such as hard drive or CD-ROM drive.|



```{r}
knitr::include_graphics("figures/umask.png")
```

The first three permission digits described in page 122 on <the Linux command line>.  

## permission attributes  
```{r}
knitr::include_graphics("figures/permission.png")
```

```{r, fig.cap="Permission Attributes"}
knitr::include_graphics("figures/permission-attributes.png")
```

```{r}
knitr::include_graphics("figures/permission-examples.png")
```

`chmod` supports two distinct ways of specifying mode changes: octal number representation, or symbolic representation.  

**File Modes In Binary and Octal**  
|**Octal**|**Binary**|**File Mode**|  
|:--|:--|:--|
|`0`|000|---|
|`1`|001|--x|
|`2`|010|-w-|
|`3`|011|-wx|
|`4`|100|r--|
|`5 = 4 + 1`|101|r-x|
|`6 = 4 + 2`|110|rw-|
|`7 = 4 + 3`|111|rwx|


**chmod Symbolic Notation**  
|**Symbol**|**Meaning**|
|:--|:--|
|`u`|short for 'user' but means the file or directory owner.|
|`g`|group owner|
|`o`|short for 'others', but means world.|
|`a`|short for 'all'. The combination of 'u', 'g' and 'o'.|

```{r}
knitr::include_graphics("figures/chmod-symbolic-notation-examples.png")
```

```{bash}
> test.txt
ls -lh test.txt

chmod 400 test.txt
ls -lh test.txt

chmod 700 test.txt
ls -lh test.txt

rm test.txt
```



```{bash}
> foo.txt

ls -lh foo.txt
chmod u+x,go=rw foo.txt
ls -lh foo.txt

chmod go-w foo.txt
ls -lh foo.txt

rm foo.txt
```


```{r}
knitr::include_graphics("figures/permission-example-1.png")
```

> '+' indicates that a permission is to be added.  
> '-' indicates that a permission is to be removed.  
> '=' indicates that only the specified permissions are to be applied and that all other are to be removed.  
> multiple specifications separated by commas.  


## file type  
- `-`: a regular file  
- `d`: a directory  
- `l`: a symbolic link. with symbolic links, the remaining file attributes are always 'rwxrwxrwx'  
- `c`: a character special file. This file type refers to a device that handles data as a stream of bytes, such as a terminal or modem.  
- `b`: a block special file. This file type refers to device that handles data in blocks, such as a hard drive or CD-ROM drive.  


## changing identities
- `su`: allows you to assume the identity of another user  
- `sudo`: allows an administrator to set up a configuration file called /etc/sudoers, and define specific commands that particular users are permitted to execute under an assumed identity.  

The syntax of `chown`  
```
chown [owner][:[group]] file...
```


**`chown` argument examples**

|**Argument**|**Results**|
|:--|:--|
|`bob`|changes the ownership of the file from its current owner to user bob|
|bob:users|changes the ownership of the file from its current owner to user bob and changes the file group owner to group users|
|`:admins`|changes the group owner to the group admins. The file owner is unchanged.|
|`bob:`|changes the file owner from the current owner to user bob and changes the group owner to the login group of user bob.|


## change password
1. `password`: enter the password to change your password, if you have superuser privileges, you can specify a username as an argument to the password command to set the password for another user.  

```
passwd [user]
```


## processes
Processes are how Linux organizes the different programs waiting for their turn at the CPU.  

1. `ps`: report a snapshot of current processes, just the processes associated with the current terminal session.  
```{bash}
ps aux | head -n 5
```


2. `top`: display tasks  
3. `jobs`: list active jobs  

### Putting a process in the background
4. `bg`: place a job in the background  
    - bg gedit &; bg notepad-plus-plus &  

### returning a process to the foreground
5. `fg`: place a job in the foreground  
    - with the fg command, the jobspec is optional if there is only one job  
    - fg %1; fg 2%  

### Stopping (Puasing) A Process 
6. `Ctrl-z`: stopping a process  

### Interrupting a process
7. `Ctrl-c`: interrupts a program, terminate a program  

## Signals
8. `kill`: send a signal to a process  
    - kill [-signal] PID  
    - kill PID; kill %[:digit:] (kill an background running program)  


**Common Signals**  
|**Number**|**Name**|**Meaning**|
|:--|:--|:--|
|`1`|HUP|Hangup. The signal is used to indicate to programs that the controlling terminal has "hung up". The effect of this signal can be demonstrated by closing a terminal session. The foreground program running on the terminal will be sent the signal and will terminate.|
|`2`|INT|Interrupt. Performs the same as the Ctrl-c key sent from the terminal. It will usually terminate a program.|
|`3`|QUIT|Quit|
|`9`|KILL|Kill. This signal is special. Whereas programs may choose to handle signals sent to them in different ways, including ignoring them in different ways, including ignoring them all together, the KILL signal is never actually sent to the target program. Rather, the kernel immediately terminates the process. When a process is terminated in this manner, it is given no opportunity to 'clean up' after itself or save its work. For this reason, the KILL signal should only be used as a last resort when other termination signals fail.|
|`11`|SEGV|Segmentation Violation. This signal is sent if a program makes illegal use of memory, that is, it tried to write somewhere it was not allowed to.|
|`15`|TERM|Terminate. This is the default signal sent by the kill command. If a program is still 'alive' enough to receive signals, it will terminate.|
|`18`|CONT|Continue. This will restore a process after a STOP signal.|
|`19`|STOP|Stop. This signal causes a process to pause without terminating. Like the KILL signal, it is not sent to the target process, and thus it cannot be ignored.|
|`20`|TSTP|Terminal Stop. This is the signal sent by the terminal when the Ctrl-z key is pressed. Unlike the STOP signal, the TSTP signal is received by the program but the program may choose to ignore it.|
|`28`|WINCH|Window Change. This is a signal sent by the system when a window changes size. Some programs, like top and less will respond to this signal by redrawing themselves to fit the new window dimensions.|

- killall: sending signals to multiple processes  
    - killall [-u user] [-signal] name ...  
- shutdown: shutdown or reboot the system  

> Processes, like files, have owners, and you must be the owner of a process (or the superuser) in order to sent it signals with kill.  
> for the complete list of signals following the command: kill -l  

**process related commands**  
|**Command**|**Description**|
|:--|:--|
|`pstree`|Outputs a process list arranged in a tree-like pattern showing the parent/child relationships between processes.|
|`vmstat`|Outputs a snapshot of system resource usage including memory, swap and disk I/O. To see a continuous display, follow the command with a time delay (n seconds) for updates.|
|`xload`|A graphical program that draws a graph showing system load over time.|
|`tload`|Similar to the xload program, but draws the graph in the terminal.|


**Process States**  
|**State**|**Meaning**|  
|:--|:--|
|`R`|Runing. This means that the process is running or ready to run.|  
|`S`|Sleeping. The process is not running; rather, it is waiting for an event, such as a keystroke or network packet.|
|`D`|Uninterruptible Sleep. Process is waiting for I/O such as disk drive.|
|`T`|Stopped. Process has been instructed to stop.|
|`Z`|A defunct or 'zombie' process. This is a child process that has terminated, but has not been cleaned up by its parent.|
|`<`|A high priority process. It's possible to grant more importance to a process, giving it more time on the CPU. This property of a process is called niceness. A process with high priority is said to be less nice because it's taking more of the CPU's time, which leaves less for everybody else.|
|`N`|A low priority process. A process with low priority (a 'nice' process) will only get processor time after other processes with higher priority have been serviced.|


# The Environment
The shell maintains a body of information during our shell session called the environment. Data stored in the environment is used by programs to determine facts about our configuration. While most programs use configuration files to store program settings, some programs will also look for values stored in the environment to adjust their behavior.  

The shell stores two basic types of data in the environment:  
- environment variables: environment variables are basically everything else.  
- shell variables: shell variables are bits of data placed there by bash.  

In addition to variables, the shell also stores some programmatic data, namely *aliases* and *shell functions*.  

***

1. `printenv`: print part or all of the environment, show only environment variable  
```{bash}
# print all environment variable
printenv

# print specific environment variable
printenv USER
```


2. `set`: set shell options, show both shell and environment variables  
```{bash}
# print shell and environment variable and any defined shell functions
set

# view the contents of a variable
echo $HOME
```

3. `export`: export environment to subsequently executed programs  
4. `alias`: create an alias for a command  
```{bash}
# alias element doesn't displayed by set or printenv

alias
```



**Startup files for login shell sessions**  
|**File**|**Contents**|
|:--|:--|
|`/etc/profile`|A global configuration script that applies to all users.|
|`/etc/bash.bashrc`|A global configuration script that applies to all users.|
|`~/.bashrc`|A user's personal startup file. Can be used to extend or override settings in the global configuration script.|

# vim
- open file with vim, if file doesn't exist it will create one  
```
vim file
```

- quit vim
```
:q  # if changes not saved a prompte will appearse
:q! # without save changes
```

- enter edition mode
```
i : edition at the cursor
a : edition at the end of the line
```

- save changes
```
:w
ZZ save and exit vim
:wq the combination of :q and :w
```

- delete line
```
dd  : delete the current line
5dd : delete the current line and the following 4 lines
```

- search line 
```
f + text: fa search a at the current line
semicolon for the next match
```

- search the file
```
/ + text + ENTER: /an search an at the entire file
n for the next following appearence of the searched text
N for the next foward appearence of the searched text
```

- edit multiple files
```
vim file1 file2 file3 ...
```

- switching between files
```
:n - next file
:N - previous file
:buffers - list all opened files
:buffer 2 - switch to the second file
```

- open additional file for edition
```
:e + file-for-edition
```

- copy a line
```
yy
```

- paste
```
p: paste after the cursor
ctrl + p: paste before the cursor
```

- inserting an entire file into another
```
:r foo: read the entire foo file into the current file
```

# package management
**The most important determinant of distribution quality is the packaging system and the vitality of the distribution's supported community.**

Package management is an method of installing and maintaining software on the system.

Different distribution use different packaging systems and as a general rule, a package intended for one distribution is not compatible with another distribution.

Most distribution fall into one or two camps of packaging technologies: the Debain '.deb' camp and the Red Hat '.rpm' camp.

### package files
The basic unit of software in a packaging system is the *package file*. A package file is a compressed collection of files that comprise the software package. A package may consist of numerous programs and data files that support the programs.


### find a package in a repository
```
apt-get update
apt-cache search search_string
```

### installing a package from a repository
```
apt-get update ; apt-get install package_name

dpkg --install package_file
```

### removing a package
```
apt-get remove package_name
```

### updating package from a repository
```
apt-get update ; apt-get upgrade

dpkg --install package_file
```

### listing installed packages
```
dpkg --list
```


### determining if a package is installed
```
dpkg --status package_name
```


### displaying info about an installed package
```
apt-cache show package_name
```

### finding which package installed a file
```
dpkg --search file_name
```

# Storage Media
1. `mount`: mount a file system.  
```{bash}
# mount without argument will display a list of the file systems currently mounted
mount

# change mount point
mount -t vfat /dev/sdb1 /mnt/usb
```

2. `umount`: umount a file system.  
3. `fsck`: check and repair a file system.  
4. `fdisk`: partition table manipulator.  
```{bash}
sudo umount /dev/sdb1
sudo fdisk /dev/sdb
```

5. `mkfs`: crete a file system.  
6. `fdformat`: format a floppy disk.  
7. `dd`: write block oriented data directly to a device.  
8. `genisoimage (mkisofs)`: create an ISO 9660 image file.  
9. `wodim (cdrecord)`: write data to optical storage media.  
10. `md5sum`: calculate an MD5 checksum.  


# Networking
When is comes to networking, there is probably nothing that cannot be done with Linux. Linux is used to build all sorts of networking systems and applicances, including firewalls, routers, name servers, NAS (Network Attached Storage) boxes and on and on.

1. `ping` - send an ICMP ECHO_REQUEST to network hosts.  
```{bash}
ping linuxcommand.org
```

2. `traceroute` - displays a listing of all the 'hops' network traffic takes to get from the local system to a specified host.  
```{bash}
traceroute slashdot.org
```

3. `netstat` - print network connections, routing tables, interface statistics, masquerade connections, and multicast memberships.  
```{bash}
netstat -ie
```

4. `ftp` - internet file transfer program.  
5. `wget` - Non-interactive network downloader.  
6. `ssh` - OpenSSH SSH client (remote login program).  
7. IP (Internet Protocol) address.  
8. Host and domain name.  
9. URI (Uniform Resource Identifier).  



# Searching files
1. `locate`: find files by name.  
The `locate` program performs a rapid database search of *pathnames*, and then outputs every name that matches a given substring.  
```{bash}
locate bin/zip

# update the data base if locate does not work
updatedb
```

2. `find`: search a given directory (and its subdirectories) for files based on a variety of attributes.   

The beauty of `find` is that is can be used to identify files that meet specific criteria. It does this through the application of *options*, *test*, and *actions*.

**test**  
```{bash}
# list directories in a directory
find ~ -type d

# list files in a directory
find ~ -type f

find ~ -type file -name '*.png' -size +1K | wc -l
```

**file types**
|**File Type**|**Description**|
|:--|:--|
|`b`|black special device file|
|`c`|character special device file|
|`d`|directory|
|`f`|regular file|
|`l`|symbolic link|

**Other test**
|**Test**|**Description**|
|:--|:--|
|`-cmin n`|Match files or directories whose **content or attributes** were last modified exactly n minutes ago.|
|`-ctime n`|Match files or directories whose **contents or attributes** were last modified n*24 hours ago.|
|`mmin n`|Match files or directories whose **contents** were last modified n minutes ago.|
|`-mtime n`|Match files or directories whose **contents** were last modified n*24 hours ago.|
|`-atime n`|File was last **accessed** n*24 hours ago.|
|`-amin n`|File was last **accessed** n minutes ago.|
|`-cnewer file`|Match files or directories whose **contents or attributes** were last modified more recently than those of file.|
|`-newer file`|Match files and directories whose **contents** were modified more recently than the specified file.|
|`-size n`|Match files of size n.|
|`-type c`|Match files of type c.|
|`-user name`|Match files or directories belonging to user name.|
|`-perm mode`|Match files or directories that have permissions set to the specified mode.|
|`-nogroup`|Match files or directories that have permissions set to the specified mode.|
|`nouser`|Match file and directories that do not belong to a valid user.|
|`-name pattern`|Match files and directories with the specified wildcard pattern.|
|`-iname pattern`|Like the -name test but case insensitive.|
|`-group name`|Match file or directories belonging to group.|
|`-empty`|Match empty files and directories.|
|`-inum n`|Match files with inode number n. This is helpful for finding all the hard links to a particular inode.|
|`-samefile name`|Similar to the -inum test. Matches files that share the same inode number as file name.|

> a: file accessed
c: change of file's status
m: file's data modified

**operators**  
provide logical relationships between the test.  
```{bash}
# (expression 1) -or (expression 2)
find ~ \( -type f -not -perm 0600 \) -or \( -type d -not -perm 0700 \)
```

In all cases, *expr1* will always be performed; however, the operator will determine if *expr2* will performed.

|**Results of expr1**|**Operator**|**expr2**|
|:--|:--|:--|
|`True`| -and| always performed|
|`False`| -and| nerver performed|
|`True`| -or| nerve performed|
|`False`| -or| always performed|


|**Operator**|**Description**|
|:--|:--|
|`-and`|Match if the tests on both sides of the operator are true. May be shortened to -a.|
|`-or`|Match if a test on either side of the operator is true. May be shortened to -o.|
|`-not`|Match if the test following the operator is false. May be abbreviated with an exclamation point (!).|
|`()`|Groups tests and operators together to form larger expressions.|



**actions**  
Having a list of results from find command but what we really want to do is performed by predefined action parameters.  

|**Action**|**Description**|
|:--|:--|
|`-delete`|delete the currently matching file.|
|`-ls`|perform the equivalent of `ls -dils` on the matching file.|
|`-print`|output the full pathname of the matching file to standard output.This is the default action.|
|`-quit`|quit once a match has been made.|

```{bash}
find ~ -type f -name '.BAK' -print
find ~ -type f -name '.BAK' -delete
```


**user-defined actions**  
```{bash}
# grammar
-exec command '{}'';'

# where command is the name of a command, {} is a symbolic representation of the current pathname, and the semicolon is a required delimiter indicating the end of the command.


# since the brace and semicolon characters have special meaning to the shell, they must be quoted or escaped
```


where command is the name of a command, {} is a symbolic representation of the current pathname, and the semicolon is a required delimiter indicating the end of the command.  

```{bash, eval = F}
find . -type f -name 'so*' -exec ls -lh '{}' ';'
```

*By changing the trailing semicolon character to a plus sign, we activate the ability of `find` to combine the results of the search into an argument list for a single execution of the desired command*. By change ';' to + the system has to execute the ls -l command for only once.

```{bash, eval = F}
find . -type f -name 'foo*' -exec ls -lh '{}' +
```


3. `xargs`: The `xargs` command performs an interesting function. It accepts input from standard input and converts it into an argument list for a specified command.  
```{bash, eval=F}
find . -type f -name 'foo*' -print | xargs ls -lh

# dealing with bad file names
find . iname '*.png' -print0 | xargs --null ls -l
```

While the number of arguments that can be placed into a command line is quite large, it’s not unlimited. It is possible to create commands that are too long for the shell to accept. When a command line exceeds the maximum length supported by the system, `xargs` executes the specified command with the maximum number of arguments possible and then repeats this process until standard input is exhausted.


4. `touch`: change file times.  
5. `stat`: display file or file system status.  


**options**  
The options are used to control the scope of a `find` search.  
```{bash}
find . -type f -maxdepth 3 -name 'foo*' -exec ls -l "{}" ";"
```

|**Option**|Description**|
|:--|:--|
|`-depth`|direct find to process a directory's files before the directory itself. This options is automatically applied when the -delete action is specified.|
|`-maxdepth levels`|Set the maximum number of levels that find will descend into a directory tree when performing tests and actions.|
|`-mindepth levels`|Set the minimum number of levels that find will descend into a directory tree before applying tests and actions.|
|`-mount`|direct find not to traverse directories that are mounted on other file systems.|
|`-noleaf`|direct find not to optimize its search based on the assumption that it is searching a Unix-like file system. This is needed when scanning DOS/Windows file systems and CD-ROMs.|

# Archiving and backup
1. `gzip`  
the `gzip` program is used to compress one or more files. The `gunzip` program is used to restore compressed files to their original.  
```{bash}
ls -l /etc > foo.txt
ls -l foo.txt

gzip foo.txt
ls -lh
gunzip foo.txt.gz
ls -lh

rm foo*
```


2. `bzip2`
The `bzip2` program is similar to `gzip`, but uses a different compression algorithm that achieves higher levels of compression at the cost of compression speed.  
```{bash}
ls -l /etc > foo.txt
bzip2 foo.txt

# uncompression
bzip2 -d foo.txt.bz2
bunzip2 foo.txt.bz2
```

All the options (except for -r) that discussed for `gzip` are also supported in `bzip2`.  

`bzip2` also comes with the `bzip2recover` program, which will try to recover damaged `.bz2` files.

### Archiving Files
A common file-management task often used in conjunction with compression is archiving. Archiving is the process of gathering up many files and bundling them together into a single large file.  

3. `tar`  
In the Unix-like world of software, the `tar` program is the classic tool for archiving files. Its name, short for *tape archive*, reveals its roots as a tool for making backup tapes.  

A tar archive can consist of a group of separate files, one or more directory hierarchies, or a mixture of both.  

```
tar mode[options] pathname ...
```

**tar mode**  

|**Mode**|**Description**|
|:--|:--|
|`c`| Create an archive from a list of files and/or directories|
|`x`| Extract an archive|
|`r`| Append specified pathnames to the end of an archive|
|`t`| List the contents of an archive|


```{bash, eval = F}
# archive a directory
tar cf   playground.tar playground
#   mode option         pathname

# the mode must always be specified first, before any other option

# list contents of a archive
tar tf playground.tar

# extract specified file
tar xf archve.tar pathname
# by adding the tailing pathname to the command, tar will only restore the specified file.

# support wildcards
tar xf archive.tar --wildcards 'pathname'

# conjunction with find
find playground -name 'file-A' -exec tar rf playgroud.tar '{}' ';'

# speed up, execute tar only once
find playground -name 'file-A' -exec tar rf playgroud.tar '{}' '+'

# using the pipe and xargs 
find playground -name 'file-A' | xargs tar cf playground.tar

find playground -name 'file-A' | xargs tar cf playground.tar | gzip > playground.tgz

# tar can internally using gzip or bzip2 wile archiving
find playground -name 'file-A' | xargs tar cfz playground.tgz
```


4. `zip`  
The `zip` program is both a compression tool and an archiver.

```
# syntax
zip options zipfile file...
```

```{bash}
zip -r playground.zip playground

unzip playground.zip

find playground -name 'file-A' | zip -@ 'file-A.zip'
# pile the find list to -@

ls -l /etc | zip ls.zip -
# pipe ls -l output to -
```

If an existing archive is specified, it is updated rather than replaced. This means that the existing archive is preserved, but new file are added and matching files are replaced.

`zip` can accept standard input, and unzip does not accept standard input.

The main use of `zip` and `unzip` program is for exchangeing files with windows system, rather than performing compression and archiving on Linux.

### Synchronizing Files and Directories
A common strategy for maintaining a backup copy of a system involves keeping one or more directories synchronized with another directory (or directories) located on either the local system or remote system.  


5. `rsync`  




## tar modes
|**Mode**|**Description**|
|:--|:--|
|`c`|Create an archive from a list of files and/or directories|
|`x`|Extract an archive.|
|`r`|Append specified pathnames to the end of an archive.|
|`t`|List the contents of an archive.|

## Examples 
```
tar cf playground.tar ../playground
```
Creates a tar archive named playground.tar that contains the entire playground directory hierarchy.


```
mkdir foo
cd foo

tar xf ../playground.tar
```
Extract the playground into a new location.  


## limit extract from an archive
```
tar xf archive.tar pathname
```
By adding the trailing pathname to the command, tar will only restore the specified file. Multiple pathnames may be specified. Note that the pathname must be the full, exact relative pathname as stored in the archive.  

The GUN version of tar supports the --wildcards option.  

```
cd foo 
tar xf ../playground.tar --wildcards 'playground/dir-*/file-A'
```

tar is often used in conjunction with find to produce archives. 

```
find playground -name 'file-A' -exec tar rf playground.tar '{}' '+'
```

# zip
The zip program is both a compression tool and an archiver.  

## usage 
```
zip options zipfile file...
```

```{r}
zip -r playground.zip playground
```

Unless we include the -r option for recursion, only the playground directory (but none of its contents) is stored.  

If an existing archive is specified, it is updated rather than replaced. This means that the existing archive is preserved, but new files are added and matching files are replaced.  

# rsync
This program can syn- chronize both local and remote directories by using the rsync remote-update protocol, which allows rsync to quickly detect the differences between two directories and per- form the minimum amount of copying required to bring them into sync. This makes rsync very fast and economical to use, compared to other kinds of copy programs.  

## usage
```
rsync options source destination
```
where source and destination are one of the following:  

- a local file or directory  
- a remote file or directory in the form of [user@]host:path]  
- a remote rsync server specified with a URI of rsync://[user@]host[:port]/path  

> Note that either the source or the destination must be a local file. Remote-to-remote copy is not supported.  

```
mkdir foo

rsync -av playground foo

sudo rsync -ac --delete /etc /home /usr/local /media/bigdisk/backup
```
the --delete option to remove files that may have existed on the backup device that no longer existed on the source de- vice (this is irrelevant the first time we make a backup, but will be useful on subsequent copies).  

## backup over a network
```
sudo rsync -av --delete --rsh=ssh /etc /home /usr/local remote-sys:/backup
```
First, we added the --rsh=ssh option, which instructs rsync to use the ssh program as its remote shell. In this way, we were able to use an ssh encrypted tunnel to securely transfer the data from the local system to the remote host. Second, we specified the remote host by prefixing its name (in this case the remote host is named remote-sys) to the destination pathname.  


# regular expressions
Regular expression are symbolic notations used to identify patterns in text.
grep searches text files for the occurrence of a specified regular expression and outputs any line containing a match to standard output.  

## grep
```
grep [options] regex [file...]
```

**grep Options**

|**Option**|**Description**|
|:--|:--|
|`-i`|ignore case|
|`-v`|invert match|
|`-c`|print the number of matches instead of the lines themselves. may also be specified --count|
|`-l`|print the name of each file that contains a match instead of the line themselves. may also be specified --files-without-match|
|`-L`|like the -l option, but print only the names of files that do not contain matches. may also be specified --files-without-match|
|`-n`|prefix each matching line with the number of the line within the file. may also be specified --line-number|
|`-h`|for multi-file searches, suppress the output of filenames. may also be specified --no-filename|


## metacharacters
- `^`: begining anchor  
- `$`: end anchor  
- `.`: any character  
- `[`  
- `]`  
- `{}`: match an element a specific number of times  
- `-`  
- `?`: match an element zero or one time  
- `*`: match an element zero or more times 
- `+`: match an element one or more times  
- `(`  
- `)`  
- `|`  
- `\`  

### The difference between basic regular expression and Extended regular expression

It's only about metacharacters. 

The basic regular expression have the following metacharacters
- `^`  
- `$`  
- `.`  
- `[`  
- `]`  
- `*`  

all other charcaters are considered literals. 



The extended regular expression has the follwoing metacharacters
- `^`  
- `$`  
- `.`  
- `[`  
- `]`  
- `*`  

**the following are added**  
- `(`  
- `)`  
- `{`  
- `}`  
- `?`  
- `+`  
- `|`



All other characters are considered literals, though the backslash character is used in a few case to create *meta sequences*, as well as allowing the metacharacters to be escaped and treated as literals instead of being interpreted as metacharacters.  

When we pass regular expressions containing metacharacters on the command line, it is vital that they enclosed in quotes to prevent the shell from attempting to expand them.  


**POSIX Character Classes**

|**Character Class**|**Description**|
|:--|:--|
|`[:alnum:]`|The alphanumeric characters. In ASCII, equivalent to [A-Za-z0-9]|
|`[:word:]`|The same as [:alnum:], with the addition of the underscore (_) character.|
|`[:alpha:]`|The alphabetic characters. In ASCII, equivalent to: [A-Za-z]| 
|`[:blank:]`|Includes the space and tab characters.|
|`[:cntrl:]`|The ASCII control codes. Includes the ASCII characters 0 through 31 and 127|
|`[:digit:]`|The numerals zero through nine.|
|`[:graph:]`|The visible characters. In ASCII, it is includes characters 33 through 126.|
|`[:lower:]`|The lowercase letters.|
|`[:punct:]`|The punctuation characters. In ASCII, equivalent to: [-!"#$%&'()*+,./:;<=>?@[\\\]_`{|}~]|
|`[:print:]`|The printable characters. All the characters in [:graph:] plus the space character.|
|`[:space:]`|The whitespace characters including space, tab, carriage return, newline, vertical tab, and form feed. In ASCII, equivalent to: [ \t\r\n\v\f]|
|`[:upper:]`|The uppercase characters.|
|`[:xdigit:]`|Characters used to express hexadecimal numbers. In ASCII, equivalent to: [0-9A-Fa-f]|

```{bash}
grep -h '[ABCDEFGHIJKLMNOPQRSTUVWXYZ]' dirlist-*.txt

grep -h '[[:upper:]]' dirlist-*.txt

ls -l /usr/bin/[[:upper:]]*

echo 'AAA' | grep AAA
echo 'AAA' | grep BBB
echo 'AAA' | grep "AAA|BBB"
echo 'AAA' | grep -E 'AAA|BBB'
grep -hE '(bz|gz|zip)' dirlist-*.txt
```


# Text Processing
1. `cat`: concatenate files and print on the standard ouput.  
```{bash}
# show the non-printing characters in the text
cat -A foo.txt

# n number the line, s remove repeated blank line
cat -ns foo.txt
```

2. `sort`: Sort lines of text files.  
```{bash}
# merge multiple files
sort dirlist-* > merged-sorted-files.txt

# sort by size, default is the first column
du -l /usr/bin | sort -nr 

# sort by the fifth column 
ls -l . | sort -nr -k 5

# sort based  on more than one columns
sort k 1, 1 -k 2nr os

sort -k 1,1 -k 3.4bn -k 3.5bn os

sort -t ":" -k 7 /etc/passwd
```

3. `uniq`: report or omit repeated lines.  
`uniq` performs a seemingly trivial task. When given a sorted file, it removes any duplicate lines and send the results to standard output. It is often used in conjunction with sort to  clean the output of duplicates.  
```{bash}
sort foo.txt | uniq

# print the duplicated time for each line
sort foo.txt | uniq -c
```


### Slicing And Dicing
4. `cut`  
The `cut` program is used to extract a section of text from a line and output extracted section to standard output. It can accept multiple file arguments or input from standard input.  

**cut Selction options**  

|**Option**|**Description**| 
|:--|:--|
|`-c char_list`|Extract the portion of the line defined by char_list. The list may consist of one or more comma-separated numerical ranges.|
|`-f field_list`|Extract one or more fields from the line as defined by field_list. The list may contain one or more fields or field ranges separated by columns.|
|`-d delim_char`|When -f is specified, use *delim_char* as the field delimiting character. By default, fields must be separated by a single tab character.|
|`--complement`|Extract the entire line of text, except for those portions specified by -c and/or -f.|


```{bash}
# extract the 3rd column from the os file
cut -f 3 os

# extract the year
cut -f 3 os | cut -c 7-10

# expand tabs to space
expand os | cut -c 23- -

# there is also unexpand for substitute tabs for space
expand os | unexpand
```

5. `paste`: merge lines of files.  
The `paste` command does the opposite of `cut`. Rather than extracting a column of text from a file, it adds one or more columns of text to a file.  

```{bash, eval=F}
paste os-date os-version
```


6. `join`: join lines of two files on a common field.  
In some ways, `join` is like `paste` in that it adds columns to a file, but it uses a unique way to do it. A join is an operation usually associated with `relational database` where data from multiple tables with a shared key fields is combined to form a desired result.

The join program performs the same operation. It joins data from multiple files based on a shared key field.  

```{bash, eval=F}
# join files by shared key column
join os-key-name os-key-version
```

### Comparing text
7. `comm`: compares two files and displays the lines that are unique to each one and the lines they have in common.  

```{bash}
comm file1 file2

# suppress output the first two fields
comm -12 file1 file2
```


8. `diff`: used to detect the differences between files. However, `diff` is a much more complex tool, supporting many output formats and the ability to process large collections of text files at once.

**diff change commands**  

|**Change**|**Description**|
|:--|:--|
|`r1ar2`|append the lines at the position r2 in the second file to the position r1 in the first file.|
|`r1cr2`|change(replace) the lines at position r1 with the lines at the position r2 in the second file.|
|`r1dr2`|delet the lines in the first file at position r1, which would have appeared at range r2 in the second file.|


```{bash}
# the default out put format
diff file1 file2

# the context output format
diff -c file1 file2

# the unified output format
diff -u file1 file2
```



9. `patch`  
The `patch` program is used to apply changes to text file. It accepts output from `diff` and is generally used to convert older version of files into newer version.

```{bash, eval = F}
# syntax
diff -Naur old_file new_file > diff_file

# where old_file and new_file are either single files or directories containing files. The r option supports recursion of a dirctory tree.

# apply the change to file1
# file1 will be identical to file2
patch < diff_file
```


### editing on the fly
10. `tr`  
translate or delete characters.  
```{bash, eval=F}
# syntax
tr option... SET1 SET2

# replace lowercase letter with uppercase letter
echo 'lowercase letter' | tr a-z A-Z
echo 'lowercase letter' | tr [:lower:] [:upper:]


# delete
echo 'lowercase letter' | tr -d 'abc'

# delete repeated sequence, the repeate must adjoining
echo 'aaabbbccc' | tr -s ab
```


`tr` accepts two arguments: a set of characters to convert from and a corresponding set of characters to convert to.  

Character sets may be expressed in one of the three ways:

- An enumerated list. for example ABCDEF  
- A character range. for example a-z  
- POSIX character classes. for example [:upper:]  

In most case, both character sets should be equal length; however, it is possible for the first set to be larger than the second, particularly if we wish to convert multiple characters to a single character.

11. `sed`  
The name `sed` is short for *stream editor*. It performs text editing on a stream of text, either a set of specified files or standard input.  

`sed` is a powerful and somewhat complex program (there are entire books about it).  

```{bash}
# search and replace
echo 'front' | sed 's/front/back'
echo 'front' | sed 's_front_back'


# most commands in `sed` may be preceded by an *address*, which specifies which line(s) of the input stream will be edited.

echo 'front' | sed '1s_front_back'

# print the first 5 lines
sed -n '1,5p' os

# print lines that contains SUSE
sed -n '/SUSE/p' os

# print lines that do not contains SUSE
sed -n '/SUSE/!p' os

# transform
# syntax
sed 's/regexp/replacement/' file

sed 's/\([0-9]\{2\}\)\/\([0-9]\{2\}\)/\([0-9]\{4\}\)$/\3-\1-\2-/' os

sed 'aaabbbccc' | sed 's/b/B'
sed 'aaabbbccc' | sed 's/b/B/g'

sed -i 's/lazy/laxy/; s/jumped/jimped/' foo.txt

sed -i 's/Ubuntu/ubuntu/' os
```


**sed Address Notation**  

|**Address**|**Description**|
|:--|:--|
|`n`| a line number|
|`$`| the last line|
|`/regexp/`| lines matching a POSIX basic regular expression|
|`adde1, addr2`| a range of lines from addr1 to ddr2, inclsive|
|`first~step`| match the line represented by the number first, then each subsequent line at step interval.|
|`addr1,+n`| match addr1 and the following n lines.|
|`addr!`| match all lines except addr, which may be any of the froms.|



12. `aspell`  
spelling checker.  

```{bash}
aspell check textfile

aspell check -H html_file
```


# Formatting Output
1. `nl`: number lines.  
```{bash}
nl os

# like 
cat -n

# like cat, nl can accept either multiple files as command line arguments, or standard input.

ls -l | nl
```

2. `fold`: Wrap each line to a specified length.  
```{bash}
# the default width is 80
echo "The brown fox jumped over the lazy dog." | fold -w 12

# the s option will avoid break in words
echo "The brown fox jumped over the lazy dog." | fold -w 12 -s
```


3. `fmt`  
`fmt` accepts either files or standard input and performs paragraph formatting on the text stream. Basically, it fills and joins lines in text while preserving blank lines and indentation.  

```{bash}

```


4. `pr`  
The `pr` program is used to paginate text.  
```{bash}
# page length 15 lines, page width 65 columns
pr -l 15 -w 65 os
```


5. `printf`: format and print data.  
```{bash}
# syntax
printf 'foramt' arguments

printf "I formatted '%s' as a string.\n" foo

printf "%+d, %.3f, %o\n" 380 380 380
```

**Common printf Data Type Specifiers**  

|**Specifier**|**Description**|
|:--|:--|
|`d`| format a number as a signed decimal integer.|
|`f`| format and output a floating point number.|
|`o`| format an integer as an octal number.|
|`s`| format a string.|
|`x`| format an integer as hexadecimal number using lowercase a-f where needed|
|`X`| Same as x but use uppercase letters.|
|`%`| Print a literal % symbol.|


###Document Formatting Systems

6. `groff`: a document formatting system.  


# Printing  
1. `pr`  
2. `lpr`  
3. `a2ps`  
4. `lpstat`  
5. `lpq`  
6. `lprm`  


# Compiling Programs
Why compile software?

- **Availability**. Despite the number of precompiled programs in distribution repositories, some ditributions may not include all the desired applications. In this case, the only way to get the desired program is to compile it from source.  

- **Timelines** While some distributions specialize in cutting edge versions of program, many do not. This means that in order to have the very latest version of a program, compiling is necessary.  

1. `make` - utility to maintain programs.  

Compiling is the process of translating source code (human-readable description of a program writtern by a programmer) into the native language of the computer's processor.


```
./configure
make
make install
```

can be used to build many source code packages.  



# Writing your first script

I fwe write a script that everyone on a system is allowed to use, the traditional location is `/usr/local/sbin`.  

scripts intended for use by the system administrator are often located in `/usr/local/sbin`.  

In most cases, locally supplied software, whether scripts or compiled programs, should be placed in the `/usr/local` hierarchy and not in `/bin` or `/usr/bin`.   


# Starting a project
**variable names**  
1. variable names may consist of alphanumeric characters (letters and numbers) and underscore characters.  
2. The first character of a variable name must be either a letter or an under score.  
3. spaces and punctuation symbols are not allowed.  

Note that in an assignment, there must be no spaces between the variable name, the equals sign, and the value.  


# Top-Down Design

**Two ways to write shell function**  

```
# type 1
function name {
    commands
    return
}


# type 2
name () {
    commands
    return
}

# where name is the name of function, commands is a series of commands contained within the function.
```

Note that in order for function calls to be recognized as shell functions and not interpreted as the names of external programs, shell functions must appear in the script before they are called.


Shell function must contain at least one command. The `return` command (which is optional) satisfies the requirement.  


### local and global variables
global variables maintain their existence throughout the program.   

local variables are only accessible within the shell function in which they are defined and cease to exist once the shell function terminates.


# Flow Control

```
# syntax

if commands; then
    commands
elif commands; then
    commands...
else
    commands
fi
```

### Exit Status
Commands (including the scripts and shell functions we write) issue a value to the system when they terminate, called an *exit status*. This value, which is an integer in the range of 0-255, indicates the success or failure of the command's execution. By convention, a value of zero indicates success and nay  othe value indicates failure. 

If a list of commands follows `if`, the last command in the list is evaluated.  

```{bash}
if true; false; then echo "It's true."; fi

if false; true; then echo "It's true."; fi
```


### A more modern version of test
```
# syntax

[[ expression ]]

```

where *expression* is an expression that evaluates to either a true or false result.  

The [[ ]] command is very similar to *test*, but adds an important new string expression.  

```
string1 = ~regex
```
which returns true if string1 matched by the extended regular expression *regex*.  

Another added feature of [[ ]] is that the == operator supports pattern matching the same way pathname expansion does.


`(())` compound command is desinged for arithmetic test.  

An arithmetic test results in true if the result of the arithmetic evaluation is none-zero. 

```{bash}
if ((1)); then echo "It is true."; fi

if ((0)); then echo "It is false."; fi
```

### Combining Expressions
There are three logical operations for *test* and *[[ ]]*. 

- `AND`  
- `OR`  
- `NOT`  

**Logical Operators**  
|**Operation**|**test**|**[[ ]] and (( ))**|
|:--|:--|:--|
|`AND`|`-a`|`&&`|
|`OR`|`-o`|`||`|
|`NOT`|`!`|`!`|


All expressions and operators used by `test` are treated as command arguments by the shell (unlike [[ ]] and (( ))), characters which have special meaning to `bash`, such as <, >, (, and, ). must be quoted or escaped.


### Control Operators: Another Way to Branch

`bash` provides two operators that perform branching. The `&& (AND)` and || (OR) operators work like the logical operators in the `[[ ]]` compound command.  

```
# syntax

command1 && command2

command1 || command2
```

With the `&&` operator, `command1` is executed and `command2` is executed if, and only if, command1 is successful. 

With the `||` operator, `command1` is executed and `command2` is executed if, and only if, `command1` is unsuccessful.

```{bash}
mkdir temp && cd temp

# create a directory named temp, and if it succeeds, the current working directory will be changed to temp.
```

```{bash}
[ -d temp ] || mkdir temp

# test for the existence of the directory temp, and only if the test fails, will the directory be created. 
```


```{bash}
[ -d temp ] || exit 1
echo $?
```


# Reading Keyboard Input
`read` - Read Values From Standard Input.  

```{bash}
# syntax

read [-options] [variable...]
```

Basically, `read` assigns fields from standard input to the specified variables.  

We use `echo` with the `-n` option (which suppresses the trailing newline on output) to display a prompt, and then use read to input a value for the variable `int`.

`read` can assign input to multiple variables.  

If `read` receives fewer than the expected number, the extra variables are empty, while an excessive amount of input results in the final variable containing all of the extra input.


**read Options**  
|**Option**|**Description**|
|`-a array`| assign the input to array, starting with index zero.|
|`-d delimiter`| The first character in the string delimiter is used to indicate end of input, rather than a newline character.|
|`-e`| Use Readline to handle input. This permits input editing in the same manner as the command line.|
|`-i string`| Use *string* as default reply if the user simply presses Enter. Requires the `-e` option.|
|`-n num`| Read `num` characters of input, rather than an entire line.|
|`-p prompt`| Display a prompt for input using the string prompt.|
|`-r`| Raw mode. Do not interpret backslash characters as escapes.|
|`-s`| Silent mode. Do not echo characters to the display as they are typed.|
|`-t seconds`| Timeout. Terminate input after *seconds*. read returns a non-zero exit status if an input times out.|
|`-u fd`| Use input from file descriptor *fd*, rather than standard input.|



### IFS (internal field separator)
The default value of IFS contains a space, a tab, and a newline character, each of which will separate items from one another.

We can adjust the value of IFS to control the separation of fields input to `read`.


### Validating Input
Very often the difference between a well-written program and a poorly written one lies in the program's ability to deal with the unexpected.



# Flow Control: Looping With while / until
## while
```
# syntax
while commands; do commands; done
```

## until
```
# syntax
until commands; do commands; done

```

# Troubleshooting
```
# only direcotry exit will changed into that directory then rm all the stuff.
[[ -d $dir_name ]] && cd $dir_name && rm *
```




















